// Generated by CoffeeScript 1.10.0
(function() {
  var Position, PossibleTurns, Weapon;

  Position = require('./position');

  Weapon = require('./weapon');

  module.exports = PossibleTurns = (function() {
    function PossibleTurns(board, position1) {
      var i, j, len, n, ref, x, y;
      this.board = board;
      this.position = position1;
      x = this.position.x;
      y = this.position.y;
      this.neighbours = [new Position(x, y - 1), new Position(x + 1, y - (x % 2 === 0 ? 1 : 0)), new Position(x + 1, y + (x % 2 === 0 ? 0 : 1)), new Position(x, y + 1), new Position(x - 1, y + (x % 2 === 0 ? 0 : 1)), new Position(x - 1, y - (x % 2 === 0 ? 1 : 0))];
      ref = this.neighbours;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        n = ref[i];
        if (!this.isFieldInsideBounds(n)) {
          this.neighbours[i] = null;
        }
      }
    }

    PossibleTurns.prototype.isFieldInsideBounds = function() {
      var ref, ref1;
      return (0 <= (ref = this.position.x) && ref <= 6) && (0 <= (ref1 = this.position.y) && ref1 <= 5);
    };

    PossibleTurns.prototype.hasToken = function(position) {
      var j, len, ref, token;
      ref = this.board.gameTokens;
      for (j = 0, len = ref.length; j < len; j++) {
        token = ref[j];
        if (position.x === token.position.x && position.y === token.position.y) {
          return token;
        }
      }
      return null;
    };

    PossibleTurns.prototype.getMoves = function() {
      var j, len, n, possibilities, ref;
      possibilities = [];
      ref = this.neighbours;
      for (j = 0, len = ref.length; j < len; j++) {
        n = ref[j];
        if (n != null) {
          if (this.hasToken(n) == null) {
            possibilities.push(n);
          }
        }
      }
      return possibilities;
    };

    PossibleTurns.prototype.getSwordAttacks = function() {
      var i, j, len, neighbourToken, possibilities, swords, token;
      possibilities = [];
      token = this.hasToken(this.position);
      swords = (function() {
        var j, results;
        results = [];
        for (i = j = 0; j <= 5; i = ++j) {
          if (token.sides[i] === Weapon.sword) {
            results.push(i);
          }
        }
        return results;
      })();
      for (j = 0, len = swords.length; j < len; j++) {
        i = swords[j];
        if (!(this.neighbours[i] != null)) {
          continue;
        }
        neighbourToken = this.hasToken(this.neighbours[i]);
        if (neighbourToken != null) {
          if (token.playerId !== neighbourToken.playerId && neighbourToken.sides[(i + 3) % 6] !== Weapon.shield) {
            possibilities.push(this.neighbours[i]);
          }
        }
      }
      return possibilities;
    };

    PossibleTurns.prototype.getArrowAttacks = function() {
      var arrows, i, j, len, maxX, maxY, possibilities, possibleTargetToken, token, x, y;
      possibilities = [];
      token = this.hasToken(this.position);
      arrows = (function() {
        var j, results;
        results = [];
        for (i = j = 0; j <= 5; i = ++j) {
          if (token.sides[i] === Weapon.arrow) {
            results.push(i);
          }
        }
        return results;
      })();
      for (j = 0, len = arrows.length; j < len; j++) {
        i = arrows[j];
        maxX = 6;
        maxY = 5;
        switch (i) {
          case 0:
            x = this.position.x;
            y = this.position.y - 1;
            while (y >= 0 && (this.hasToken(new Position(x, y)) == null)) {
              y--;
            }
            possibleTargetToken = this.hasToken(new Position(x, y));
            if (y >= 0 && (possibleTargetToken != null)) {
              if (token.playerId !== possibleTargetToken.playerId && possibleTargetToken.sides[3] !== Weapon.shield) {
                possibilities.push(new Position(x, y));
              }
            }
            break;
          case 1:
            x = this.position.x + 1;
            y = this.position.y - (x % 2 === 0 ? 1 : 0);
            while (x <= maxX && y >= 0 && (this.hasToken(new Position(x, y)) == null)) {
              x++;
              y -= (x % 2 === 0 ? 1 : 0);
            }
            possibleTargetToken = this.hasToken(new Position(x, y));
            if (x <= maxX && y >= 0 && (possibleTargetToken != null)) {
              if (token.playerId !== possibleTargetToken.playerId && possibleTargetToken.sides[4] !== Weapon.shield) {
                possibilities.push(new Position(x, y));
              }
            }
            break;
          case 2:
            x = this.position.x + 1;
            y = this.position.y + (x % 2 === 0 ? 0 : 1);
            while (x <= maxX && y <= maxY && (this.hasToken(new Position(x, y)) == null)) {
              x++;
              y += (x % 2 === 0 ? 0 : 1);
            }
            possibleTargetToken = this.hasToken(new Position(x, y));
            if (x <= maxX && y <= maxY && (possibleTargetToken != null)) {
              if (token.playerId !== possibleTargetToken.playerId && possibleTargetToken.sides[5] !== Weapon.shield) {
                possibilities.push(new Position(x, y));
              }
            }
            break;
          case 3:
            x = this.position.x;
            y = this.position.y + 1;
            while (y <= maxY && (this.hasToken(new Position(x, y)) == null)) {
              y++;
            }
            possibleTargetToken = this.hasToken(new Position(x, y));
            if (y <= maxY && (possibleTargetToken != null)) {
              if (token.playerId !== possibleTargetToken.playerId && possibleTargetToken.sides[0] !== Weapon.shield) {
                possibilities.push(new Position(x, y));
              }
            }
            break;
          case 4:
            x = this.position.x - 1;
            y = this.position.y + (x % 2 === 0 ? 0 : 1);
            while (x >= 0 && y <= maxY && (this.hasToken(new Position(x, y)) == null)) {
              x--;
              y += (x % 2 === 0 ? 0 : 1);
            }
            possibleTargetToken = this.hasToken(new Position(x, y));
            if (x >= 0 && y <= maxY && (possibleTargetToken != null)) {
              if (token.playerId !== possibleTargetToken.playerId && possibleTargetToken.sides[1] !== Weapon.shield) {
                possibilities.push(new Position(x, y));
              }
            }
            break;
          case 5:
            x = this.position.x - 1;
            y = this.position.y - (x % 2 === 0 ? 1 : 0);
            while (x >= 0 && y >= 0 && (this.hasToken(new Position(x, y)) == null)) {
              x--;
              y -= (x % 2 === 0 ? 1 : 0);
            }
            possibleTargetToken = this.hasToken(new Position(x, y));
            if (x >= 0 && y >= 0 && (possibleTargetToken != null)) {
              if (token.playerId !== possibleTargetToken.playerId && possibleTargetToken.sides[2] !== Weapon.shield) {
                possibilities.push(new Position(x, y));
              }
            }
        }
      }
      return possibilities;
    };

    return PossibleTurns;

  })();

}).call(this);
