// Generated by CoffeeScript 1.10.0
(function() {
  var Position, PossibleTurns, Weapon;

  Position = require('./position');

  Weapon = require('./weapon');

  module.exports = PossibleTurns = (function() {
    function PossibleTurns(board, position1) {
      var i, j, len, n, ref, x, y;
      this.board = board;
      this.position = position1;
      x = this.position.x;
      y = this.position.y;
      this.neighbours = [new Position(x, y - 1), new Position(x + 1, y - (x % 2 === 0 ? 1 : 0)), new Position(x + 1, y + (x % 2 === 0 ? 0 : 1)), new Position(x, y + 1), new Position(x - 1, y + (x % 2 === 0 ? 0 : 1)), new Position(x - 1, y - (x % 2 === 0 ? 1 : 0))];
      ref = this.neighbours;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        n = ref[i];
        if (!this.isFieldInsideBounds(n)) {
          this.neighbours[i] = null;
        }
      }
    }

    PossibleTurns.prototype.isFieldInsideBounds = function() {
      var ref, ref1;
      return (0 <= (ref = this.position.x) && ref <= 6) && (0 <= (ref1 = this.position.y) && ref1 <= 5);
    };

    PossibleTurns.prototype.hasToken = function(position) {
      var j, len, ref, token;
      ref = this.board.gameTokens;
      for (j = 0, len = ref.length; j < len; j++) {
        token = ref[j];
        if (position.x === token.position.x && position.y === token.position.y) {
          return token;
        }
      }
      return null;
    };

    PossibleTurns.prototype.getMoves = function() {
      var j, len, n, possibilities, ref;
      possibilities = [];
      ref = this.neighbours;
      for (j = 0, len = ref.length; j < len; j++) {
        n = ref[j];
        if (n != null) {
          if (this.hasToken(n) == null) {
            possibilities.push(n);
          }
        }
      }
      return possibilities;
    };

    PossibleTurns.prototype.getSwordAttacks = function() {
      var i, j, len, neighbourToken, possibilities, swords, token;
      possibilities = [];
      token = this.hasToken(this.position);
      swords = (function() {
        var j, results;
        results = [];
        for (i = j = 0; j <= 5; i = ++j) {
          if (token.sides[i] === Weapon.sword) {
            results.push(i);
          }
        }
        return results;
      })();
      for (j = 0, len = swords.length; j < len; j++) {
        i = swords[j];
        if (!(this.neighbours[i] != null)) {
          continue;
        }
        neighbourToken = this.hasToken(this.neighbours[i]);
        if (neighbourToken != null) {
          if (token.playerId !== neighbourToken.playerId && neighbourToken.sides[(i + 3) % 6] !== Weapon.shield) {
            possibilities.push(this.neighbours[i]);
          }
        }
      }
      return possibilities;
    };

    return PossibleTurns;

  })();


  /*
    getArrowAttacks: () ->
      possibilities = []
  
      token = @hasToken(@position)
      arrows = (i for i in [0..5] when token.sides[i] == Weapon.arrow)
  
      for i in arrows
        maxX = 6
        maxY = 5
        switch i
          when 0
            x = @position.x
            y = @position.y - 1
            while y >= 0 and not @board.tiles[x][y]?
              y--
            possibleTargetToken = @board.tiles[x][y]
            if y >= 0 and possibleTargetToken?
              if token.playerId != possibleTargetToken.playerId and possibleTargetToken.sides[3] != Weapon.shield
                possibilities.push(new Position(x, y))
  
          when 1
            x = @position.x + 1
            y = @position.y - (if x % 2 == 0 then 1 else 0)
            while x <= maxX and y >= 0 and not @board.tiles[x][y]?
              x++
              y -= (if x % 2 == 0 then 1 else 0)
            possibleTargetToken = @board.tiles[x][y]
            if x <= maxX and y >= 0 and possibleTargetToken?
              if token.playerId != possibleTargetToken.playerId and possibleTargetToken.sides[4] != Weapon.shield
                possibilities.push(new Position(x, y))
  
          when 2
            x = @position.x + 1
            y = @position.y + (if x % 2 == 0 then 0 else 1)
            while x <= maxX and y <= maxY and not @board.tiles[x][y]?
              x++
              y += (if x % 2 == 0 then 0 else 1)
            possibleTargetToken = @board.tiles[x][y]
            if x <= maxX and y <= maxY and possibleTargetToken?
              if token.playerId != possibleTargetToken.playerId and possibleTargetToken.sides[5] != Weapon.shield
                possibilities.push(new Position(x, y))
  
          when 3
            x = @position.x
            y = @position.y + 1
            while y <= maxY and not @board.tiles[x][y]?
              y++
            possibleTargetToken = @board.tiles[x][y]
            if y <= maxY and possibleTargetToken?
              if token.playerId != possibleTargetToken.playerId and possibleTargetToken.sides[0] != Weapon.shield
                possibilities.push(new Position(x, y))
  
          when 4
            x = @position.x - 1
            y = @position.y + (if x % 2 == 0 then 0 else 1)
            while x >= 0 and y <= maxY and not @board.tiles[x][y]?
              x--
              y += (if x % 2 == 0 then 0 else 1)
            possibleTargetToken = @board.tiles[x][y]
            if x >= 0 and y <= maxY and possibleTargetToken?
              if token.playerId != possibleTargetToken.playerId and possibleTargetToken.sides[1] != Weapon.shield
                possibilities.push(new Position(x, y))
  
          when 5
            x = @position.x - 1
            y = @position.y - (if x % 2 == 0 then 1 else 0)
            while x >= 0 and y >= 0 and not @board.tiles[x][y]?
              x--
              y -= (if x % 2 == 0 then 1 else 0)
            possibleTargetToken = @board.tiles[x][y]
            if x >= 0 and y >= 0 and possibleTargetToken?
              if token.playerId != possibleTargetToken.playerId and possibleTargetToken.sides[2] != Weapon.shield
                possibilities.push(new Position(x, y))
  
      possibilities
   */

}).call(this);
