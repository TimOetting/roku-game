// Generated by CoffeeScript 1.10.0
(function() {
  var Board, Game, GameApplicationService, Player, Position, PossibleActions, PossibleActionsApplicationService;

  Game = require('../domain/game');

  Player = require('../domain/player');

  Board = require('../domain/board');

  PossibleActions = require('../domain/possibleActions');

  Position = require('../domain/position');

  PossibleActionsApplicationService = require('./possibleActionsApplicationService');

  module.exports = GameApplicationService = (function() {
    function GameApplicationService() {}

    GameApplicationService.prototype.createNewGame = function() {
      var board, game, gameToken, j, len, player1, player2, ref;
      player1 = new Player(1);
      player2 = new Player(2);
      board = new Board();
      game = new Game(board, player1, player2);
      ref = game.board.gameTokens;
      for (j = 0, len = ref.length; j < len; j++) {
        gameToken = ref[j];
        gameToken.possibleActions = this.getPossibleActions(game, gameToken.id);
      }
      return game;
    };

    GameApplicationService.prototype.getPossibleActions = function(game, tokenId) {
      var arrowAttacks, moves, possibleActionsApplicationService, swordAttacks;
      possibleActionsApplicationService = new PossibleActionsApplicationService(game, tokenId);
      moves = possibleActionsApplicationService.getMoves();
      swordAttacks = possibleActionsApplicationService.getSwordAttacks();
      arrowAttacks = possibleActionsApplicationService.getArrowAttacks();
      return new PossibleActions(moves, swordAttacks, arrowAttacks);
    };

    GameApplicationService.prototype.rotate = function(game, tokenId, steps) {
      var i, j, ref, token;
      token = game.board.gameTokens[tokenId];
      for (i = j = 0, ref = Math.abs(steps); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        console.log('ding ', steps);
        if (steps > 0) {
          token.sides.unshift(token.sides.pop());
        }
        if (steps < 0) {
          token.sides.push(token.sides.shift());
        }
      }
      this._performAction(game);
      return game;
    };

    GameApplicationService.prototype.move = function(game, tokenId, position) {
      var token;
      token = game.board.gameTokens[tokenId];
      if (this._containsPosition(token.possibleActions.moves, position)) {
        token.position = position;
        this._performAction(game);
      }
      return game;
    };

    GameApplicationService.prototype.attack = function(game, attackerTokenId, targetTokenId) {
      var attack, attacker, target;
      attacker = game.board.gameTokens[attackerTokenId];
      target = game.board.gameTokens[targetTokenId];
      attack = this._getPossibleAttack(attacker, target);
      if (attack != null) {
        target = game.board.gameTokens[attack.targetId];
        target.health--;
        if (target.health === 0) {
          target.isAlive = false;
        }
        attacker.sides[attack.side].isReady = false;
        this._performAction(game);
      }
      return game;
    };

    GameApplicationService.prototype._performAction = function(game) {
      var gameToken, j, k, l, len, len1, len2, ref, ref1, ref2, side;
      game.gameState.remainingPlayerTurns--;
      if (game.gameState.remainingPlayerTurns <= 0) {
        ref = game.board.gameTokens;
        for (j = 0, len = ref.length; j < len; j++) {
          gameToken = ref[j];
          if (gameToken.playerId === game.gameState.activePlayer) {
            ref1 = gameToken.sides;
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              side = ref1[k];
              side.isReady = true;
            }
          }
        }
        game.gameState.activePlayer = 1 - game.gameState.activePlayer;
        game.gameState.remainingPlayerTurns = 6;
      }
      ref2 = game.board.gameTokens;
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        gameToken = ref2[l];
        gameToken.possibleActions = this.getPossibleActions(game, gameToken.id);
      }
      return game;
    };

    GameApplicationService.prototype._containsPosition = function(arr, pos) {
      var i, item, j, len;
      i = 0;
      for (j = 0, len = arr.length; j < len; j++) {
        item = arr[j];
        if (item.x === pos.x && item.y === pos.y) {
          return true;
        }
        i++;
      }
      return false;
    };

    GameApplicationService.prototype._getPossibleAttack = function(attacker, target) {
      var j, k, len, len1, possibleAttack, possibleAttacks, ref, side, sideId;
      possibleAttacks = attacker.possibleActions.swordAttacks.concat(attacker.possibleActions.arrowAttacks);
      for (j = 0, len = possibleAttacks.length; j < len; j++) {
        possibleAttack = possibleAttacks[j];
        ref = attacker.sides;
        for (sideId = k = 0, len1 = ref.length; k < len1; sideId = ++k) {
          side = ref[sideId];
          if (possibleAttack.targetId === target.id && possibleAttack.side === sideId && side.isReady) {
            return possibleAttack;
          }
        }
      }
    };

    return GameApplicationService;

  })();

}).call(this);
