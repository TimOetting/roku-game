// Generated by CoffeeScript 1.10.0
(function() {
  var Config, Position, PossibleActions, PossibleActionsApplicationService, Weapon;

  Position = require('../domain/position');

  Weapon = require('../domain/weapon');

  PossibleActions = require('../domain/possibleActions');

  Config = require('../config/gameConfig');

  module.exports = PossibleActionsApplicationService = (function() {
    function PossibleActionsApplicationService(game, tokenId) {
      var i, j, len, n, ref, x, y;
      this.game = game;
      this.token = this.game.board.gameTokens[tokenId];
      this.position = this.token.position;
      x = this.position.x;
      y = this.position.y;
      this.neighbours = [new Position(x, y - 1), new Position(x + 1, y - (x % 2 === 0 ? 1 : 0)), new Position(x + 1, y + (x % 2 === 0 ? 0 : 1)), new Position(x, y + 1), new Position(x - 1, y + (x % 2 === 0 ? 0 : 1)), new Position(x - 1, y - (x % 2 === 0 ? 1 : 0))];
      ref = this.neighbours;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        n = ref[i];
        if (!this.isFieldInsideBounds(n)) {
          this.neighbours[i] = null;
        }
      }
    }

    PossibleActionsApplicationService.prototype.isFieldInsideBounds = function() {
      var ref, ref1;
      return (0 <= (ref = this.position.x) && ref <= 6) && (0 <= (ref1 = this.position.y) && ref1 <= 5);
    };

    PossibleActionsApplicationService.prototype.getToken = function(position) {
      var j, len, ref, token;
      ref = this.game.board.gameTokens;
      for (j = 0, len = ref.length; j < len; j++) {
        token = ref[j];
        if (position.x === token.position.x && position.y === token.position.y) {
          return token;
        }
      }
      return null;
    };

    PossibleActionsApplicationService.prototype.getPossibleActions = function() {
      if (this.token.playerId === this.game.gameState.activePlayer) {
        return new PossibleActions(this.getMoves(), this.getSwordAttacks(), this.getArrowAttacks());
      } else {
        return new PossibleActions([], [], []);
      }
    };

    PossibleActionsApplicationService.prototype.getMoves = function() {
      var j, len, n, possibilities, ref;
      possibilities = [];
      if (this.token.playerId === this.game.gameState.activePlayer) {
        ref = this.neighbours;
        for (j = 0, len = ref.length; j < len; j++) {
          n = ref[j];
          if (n != null) {
            if (this.getToken(n) == null) {
              possibilities.push(n);
            }
          }
        }
      }
      return possibilities;
    };

    PossibleActionsApplicationService.prototype.getSwordAttacks = function() {
      var i, j, len, neighbourToken, possibilities, swords;
      possibilities = [];
      if (this.token.playerId === this.game.gameState.activePlayer) {
        swords = (function() {
          var j, results;
          results = [];
          for (i = j = 0; j <= 5; i = ++j) {
            if (this.token.sides[i].weapon === Weapon.sword && this.token.sides[i].isReady) {
              results.push(i);
            }
          }
          return results;
        }).call(this);
        for (j = 0, len = swords.length; j < len; j++) {
          i = swords[j];
          if (!(this.neighbours[i] != null)) {
            continue;
          }
          neighbourToken = this.getToken(this.neighbours[i]);
          if (neighbourToken != null) {
            if (this.token.playerId !== neighbourToken.playerId && neighbourToken.sides[(i + 3) % 6].weapon !== Weapon.shield) {
              possibilities.push({
                side: i,
                targetId: neighbourToken.id
              });
            }
          }
        }
      }
      return possibilities;
    };

    PossibleActionsApplicationService.prototype.getArrowAttacks = function() {
      var arrows, distance, i, j, k, len, neighbourToken, possibilities, ref;
      possibilities = [];
      if (this.token.playerId === this.game.gameState.activePlayer) {
        arrows = (function() {
          var j, results;
          results = [];
          for (i = j = 0; j <= 5; i = ++j) {
            if (this.token.sides[i].weapon === Weapon.arrow && this.token.sides[i].isReady) {
              results.push(i);
            }
          }
          return results;
        }).call(this);
        for (j = 0, len = arrows.length; j < len; j++) {
          i = arrows[j];
          distance = 0;
          for (distance = k = 1, ref = Config.ARROW_MAX_DISTANCE; 1 <= ref ? k <= ref : k >= ref; distance = 1 <= ref ? ++k : --k) {
            neighbourToken = this.getToken(this._getDistantNeighbour(this.position, distance, i));
            if ((neighbourToken != null) && neighbourToken.playerId !== this.token.playerId && neighbourToken.sides[(i + 3) % 6].weapon !== Weapon.shield) {
              possibilities.push({
                side: i,
                targetId: neighbourToken.id
              });
              break;
            }
          }
        }
      }
      return possibilities;
    };

    PossibleActionsApplicationService.prototype._getDistantNeighbour = function(pos, distance, direction) {
      var directionVector, outPos;
      directionVector = (function() {
        switch (false) {
          case direction !== 0:
            return {
              x: 0,
              y: -1
            };
          case direction !== 1:
            return {
              x: 1,
              y: -1
            };
          case direction !== 2:
            return {
              x: 1,
              y: 1
            };
          case direction !== 3:
            return {
              x: 0,
              y: 1
            };
          case direction !== 4:
            return {
              x: -1,
              y: 1
            };
          case direction !== 5:
            return {
              x: -1,
              y: -1
            };
        }
      })();
      outPos = {
        x: pos.x,
        y: pos.y
      };
      if (directionVector.x !== 0) {
        if (pos.x % 2 === 0) {
          outPos.y += Math.floor((directionVector.y * distance) / 2);
        } else {
          outPos.y += Math.ceil((directionVector.y * distance) / 2);
        }
      } else {
        outPos.y += directionVector.y * distance;
      }
      outPos.x += directionVector.x * distance;
      return outPos;
    };

    return PossibleActionsApplicationService;

  })();

}).call(this);
